Accessing the remote server, is usually context of a low privileged user, which would not give us complete access over the box. To gain full access, we will need to find an internal, local vulnerability that would escalate our privileges to the root user on Linux or the administrator/SYSTEM user on Windows. 

### PrivEsc Checklists
Once we gain initial access to a box, we want to thoroughly enumerate the box to find any potential vulnerabilities we can exploit to achieve a higher privilege level. We can find many checklists and cheat sheets online that have a collection of checks we can run and the commands to run these checks. One is HackTricks, which has checklist for both linux and windows. Another is PayloadsAllTheThings, which also has checklists for both linux and windows.

### Enumeration Scripts
Many of the above commands may be automatically run with a script to go through the report and loos for any weakness. We can run many scripts to automatically enumerate the server by running common commands that return any interesting findings. 

For example in Linux,
```
./linpeas.sh
Linux Privesc Checklist: https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
 LEYEND:
  RED/YELLOW: 99% a PE vector
  RED: You must take a look at it
  LightCyan: Users with console
  Blue: Users without console & mounted devs
  Green: Common things (users, groups, SUID/SGID, mounts, .sh scripts, cronjobs)
  LightMangenta: Your username


====================================( Basic information )=====================================
OS: Linux version 3.9.0-73-generic
User & Groups: uid=33(www-data) gid=33(www-data) groups=33(www-data)
...SNIP...
```
Once the script runs, it starts collecting information and displaying it in an excellent report. Let us discuss some of the vulnerabilities that we should look for in the output from these scripts. 

### Kernel Exploits
Whenever we encounter a server running an old operating system, we should start by looking for potential kernel vulnerabilities that may exist. Not updated server for example, might be vulnerable. 

### Vulnerable software
Installed software is another thing that needs to be looked after. We can use dpkg -l command on Linux or look at C:\Program Files in windows to see what software is installed on the system. We should look for public exploits for any installed software, especially if any older versions are in use, containing unpatched vulnerabilities. 

### User Privileges
Another critical aspect to look for after gaining access to a server is the privilege avaiable to the user we have access to. Suppose we are allowed to run specific commands as root. In that case, we may be able to escalate out privileges to root system users or gain access as a differennt user. Below are some common ways to exploit certain user privileges. 

Sudo, SUID, Windows Token Privileges

The sudo command in LInux allows a user to execute commands as a different user. It is usually used to allow lower privileged users to execute commands as root without giving them access to the root user. This is generally done as specific commands can only be run as root like tcpdump or allow the user to access certain root - only directories. We can check what sudo privileges we have with the sudo -l command. 
```
kwc0827@htb[/htb]$ sudo -l

[sudo] password for user1:
...SNIP...

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```
The above output says that we can run all command with sudo, which gives us complete access, and we can use the su command with sudo to switch to the root users.
```
kwc0827@htb[/htb]$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```
NOPASSWD entry shows that bin/echo command can be executed without a password. This would be useful if we gained access to the server through the vulnerability and did not have the users’s password. As it says user, we can run sudo as that user and not as root. To do so, we can specify the user with -u user. 
```
sudo -u user /bin/echo Hello World!
```
Once we find a particular application we can run with sudo, we can look for ways to exploit to get a shell as the root user. GTFOBins contains a list of command and how they can be exploited through sudo. We can search for the application we have sudo privilege over, and if it exists, it may tell us the exact command we should execute to gain root access using the sudo privilege we have. 

LOLBAS also contains a list of Windows application which we may be able to leverage to perform certain functions, like downloading files or executing commands in the context of a privileged user.

### Scheduled Tasks
In both Linux and Windows, there are methods to have scripts run at specific intervals to carry out a task. Some examples are having an anti-virus scan running every our or a back script that runs every 30 minutes. These are usually two ways to take advantage of scheduled tasks or cron jobs to escalate our privilege. 
1. Add new scheduled tasks / cron jobs
2. Trick them to execute a malicious software

## SSH Keys

If we have read across over the .ssh directory for a specific user, we may read their private ssh keys found in .ssh/id_rsa, and use it to login to the server. If we can read the /root/. Ssh/ directory and can read the id_rsa file, we can copy it to our machine and use the -i flag to log in with it.
```
vim id_rsa
chmod 600 id_rsa
ssh root@10.10.10.10 -i id_rsa
```
If we find ourselves with write access to a users/ .ssh/directory, we can place our public key in the user’s ssh directory at /home/user/. Ssh/authorized_keys. This technology is usually used to gain ssh access after gaining a shell as that user. The current SSH configuration will not accept keys written by other users, so it will only work if we have already gained control over that user. We must first create a new key with ssh-keygen and the -f flag to specify the output file. 

```
ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:...SNIP... user@parrot
The key's randomart image is:
+---[RSA 3072]----+
|   ..o.++.+      |
...SNIP...
|     . ..oo+.    |
+----[SHA256]-----+
```
This will give us two files: key and key. Pub, which we will copy to the remote machine. Let us copy key. Pub, then on the remote machine, we will add it into /root/. Ssh/authorized_keys

```
user@remotehost$ echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```
Now the remote server should allow us to log in as that user by using our private key:
```
kwc0827@htb[/htb]$ ssh root@10.10.10.10 -i key
```

